<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Optimized NiftyGroww Market Sniper</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            background: #ffffff;
            color: #1a1a1a;
            min-height: 100vh;
            position: relative;
        }
        
        .game-container {
            max-width: 100vw;
            margin: 0 auto;
            position: relative;
            background: #ffffff;
            overflow-y: auto; /* Allow vertical scrolling */
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: clamp(20px, 4vw, 28px);
            font-weight: 700;
            margin-bottom: 5px;
        }
        
        .header p {
            font-size: clamp(12px, 2.5vw, 14px);
            opacity: 0.9;
        }
        
        #gameCanvas {
            background: #fafafa;
            border: 2px solid #e1e5e9;
            border-radius: 12px;
            display: block;
            margin: 20px auto;
            box-shadow: 0 4px 20px rgba(0,0,0,0.08);
            max-width: 95vw;
            height: auto;
            touch-action: pinch-zoom; /* Allow pinch-zoom, prevent default panning */
        }
        
        .hud {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 15px;
            padding: 20px;
            background: white;
            margin: 0 20px;
            border-radius: 12px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.06);
            border: 1px solid #e1e5e9;
        }
        
        .stat {
            text-align: center;
            padding: 15px 10px;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
            transition: all 0.2s ease;
        }
        
        .stat:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        .stat-label {
            font-size: clamp(11px, 2vw, 13px);
            color: #6c757d;
            margin-bottom: 8px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: clamp(16px, 3vw, 20px);
            font-weight: 700;
            color: #2c3e50;
        }
        
        .portfolio .stat-value {
            color: #27ae60;
        }
        
        .accuracy .stat-value {
            color: #3498db;
        }
        
        .streak .stat-value {
            color: #e74c3c;
        }
        
        .risk .stat-value {
            color: #f39c12;
        }
        
        .controls-section {
            margin: 20px;
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 2px 15px rgba(0,0,0,0.06);
            border: 1px solid #e1e5e9;
        }
        
        .patience-container {
            margin-bottom: 20px;
        }
        
        .patience-label {
            font-size: 14px;
            color: #6c757d;
            margin-bottom: 10px;
            font-weight: 500;
            text-align: center;
        }
        
        .patience-bar {
            width: 100%;
            max-width: 400px;
            height: 12px;
            background: #e9ecef;
            border-radius: 20px;
            overflow: hidden;
            margin: 0 auto;
            border: 1px solid #dee2e6;
        }
        
        .patience-fill {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c 0%, #f39c12 50%, #27ae60 100%);
            width: 0%;
            transition: width 0.1s ease;
            border-radius: 20px;
        }
        
        .crosshair {
            position: fixed;
            pointer-events: none;
            z-index: 200;
            width: 24px;
            height: 24px;
            border: 2px solid #667eea;
            border-radius: 50%;
            opacity: 0.8;
            background: rgba(102, 126, 234, 0.1);
            transform: translate(-50%, -50%);
            transition: transform 0.05s linear;
        }
        
        .crosshair::before,
        .crosshair::after {
            content: '';
            position: absolute;
            background: #667eea;
        }
        
        .crosshair::before {
            width: 2px;
            height: 16px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        
        .crosshair::after {
            width: 16px;
            height: 2px;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }
        
        .instructions {
            text-align: center;
            font-size: clamp(12px, 2.5vw, 14px);
            color: #6c757d;
            line-height: 1.6;
            max-width: 600px;
            margin: 0 auto;
        }
        
        .instruction-item {
            display: inline-block;
            margin: 0 10px;
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 20px;
            border: 1px solid #e9ecef;
            margin-bottom: 8px;
        }
        
        .game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            border: 2px solid #e74c3c;
            text-align: center;
            z-index: 300;
            display: none;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 90vw;
            width: 400px;
        }
        
        .game-over h2 {
            color: #e74c3c;
            margin-bottom: 20px;
            font-size: clamp(20px, 4vw, 24px);
            font-weight: 700;
        }
        
        .game-over p {
            margin-bottom: 10px;
            color: #6c757d;
            font-size: clamp(14px, 3vw, 16px);
        }
        
        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.95) 0%, rgba(118, 75, 162, 0.95) 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 400;
            transition: opacity 0.5s ease;
        }
        
        .start-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        .start-screen h1 {
            color: white;
            font-size: clamp(28px, 6vw, 36px);
            font-weight: 700;
            margin-bottom: 20px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        
        .start-screen p {
            color: rgba(255,255,255,0.9);
            font-size: clamp(14px, 3vw, 16px);
            max-width: 500px;
            text-align: center;
            margin-bottom: 30px;
        }
        
        .button-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .game-btn {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: none;
            color: #2c3e50;
            padding: 15px 30px;
            font-size: clamp(14px, 3vw, 16px);
            font-weight: 600;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Inter', sans-serif;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            position: relative;
            overflow: hidden;
        }
        
        .game-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: 0.5s;
        }
        
        .game-btn:hover::before {
            left: 100%;
        }
        
        .game-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            background: linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%);
        }
        
        .game-btn:active {
            transform: translateY(0);
        }
        
        .start-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
        }
        
        .end-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }
        
        /* Mobile Responsive */
        @media (max-width: 768px) {
            .game-container {
                padding-bottom: 20px; /* Ensure content is accessible */
            }
            
            .hud {
                grid-template-columns: repeat(2, 1fr);
                margin: 10px;
                padding: 15px;
            }
            
            .controls-section {
                margin: 10px;
                padding: 15px;
            }
            
            .header {
                padding: 10px 15px;
            }
            
            #gameCanvas {
                margin: 10px auto;
                max-width: 98vw;
            }
            
            .instruction-item {
                display: block;
                margin: 5px auto;
                text-align: center;
            }
            
            .crosshair {
                width: 32px;
                height: 32px;
            }
            
            .crosshair::before {
                height: 20px;
            }
            
            .crosshair::after {
                width: 20px;
            }
            
            .start-screen h1 {
                font-size: clamp(24px, 5vw, 30px);
            }
            
            .start-screen p {
                font-size: clamp(12px, 2.5vw, 14px);
                padding: 0 20px;
            }
        }
        
        @media (max-width: 480px) {
            .hud {
                grid-template-columns: 1fr;
            }
            
            .stat {
                padding: 12px 8px;
            }
            
            .game-over {
                padding: 30px 20px;
                margin: 20px;
            }
            
            .button-container {
                flex-direction: column;
                align-items: center;
            }
            
            .game-btn {
                width: 80%;
                max-width: 250px;
            }
        }
        
        /* Pulse animation for opportunities */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .opportunity-pulse {
            animation: pulse 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1>NiftyGroww Market Sniper</h1>
            <p>Trade smart, aim sharp, grow your portfolio!</p>
        </div>
        
        <div class="start-screen" id="startScreen">
            <h1>Welcome to Market Sniper</h1>
            <p>Test your trading instincts! Wait for the right moment, build patience, and execute trades to grow your portfolio. Avoid traps and manage your risk wisely!</p>
            <button class="game-btn start-btn" onclick="startGame()">üöÄ Start Trading</button>
        </div>
        
        <div class="hud">
            <div class="stat portfolio">
                <div class="stat-label">Portfolio</div>
                <div class="stat-value">‚Çπ<span id="portfolio">1,00,000</span></div>
            </div>
            <div class="stat accuracy">
                <div class="stat-label">Accuracy</div>
                <div class="stat-value" id="accuracy">0%</div>
            </div>
            <div class="stat streak">
                <div class="stat-label">Win Streak</div>
                <div class="stat-value" id="streak">0</div>
            </div>
            <div class="stat risk">
                <div class="stat-label">Risk Level</div>
                <div class="stat-value" id="risk">Conservative</div>
            </div>
        </div>
        
        <canvas id="gameCanvas" width="1000" height="600"></canvas>
        
        <div class="controls-section">
            <div class="patience-container">
                <div class="patience-label">Patience Level: <span id="patiencePercent">0%</span></div>
                <div class="patience-bar">
                    <div class="patience-fill" id="patienceFill"></div>
                </div>
            </div>
            
            <div class="instructions">
                <div class="instruction-item">üü¢ Wait for green CALL setups</div>
                <div class="instruction-item">üîµ Target blue PUT opportunities</div>
                <div class="instruction-item">üî¥ Avoid red market traps</div>
                <div class="instruction-item">üñ± Hold touch to build patience</div>
                <div class="instruction-item">üìà Tap to execute trades</div>
            </div>
            
            <div class="button-container">
                <button class="game-btn end-btn" onclick="endGame()">üèÅ End Session</button>
            </div>
        </div>
        
        <div class="crosshair" id="crosshair"></div>
        
        <div class="game-over" id="gameOver">
            <h2>üö® Trading Session Ended</h2>
            <p>Your portfolio has been liquidated</p>
            <p style="font-weight: 600; color: #2c3e50;">Final Portfolio: ‚Çπ<span id="finalPortfolio">0</span></p>
            <p style="font-size: 14px; margin-top: 15px;">Accuracy: <span id="finalAccuracy">0</span>% | Best Streak: <span id="finalStreak">0</span></p>
            <button class="game-btn start-btn" onclick="restartGame()">üîÑ Start New Session</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const crosshair = document.getElementById('crosshair');
        const startScreen = document.getElementById('startScreen');
        
        // Performance optimizations
        let gridCanvas, gridCtx;
        let gridDrawn = false;
        let lastMouseMove = 0;
        let mouseX = 0, mouseY = 0;
        let crosshairUpdateRequested = false;
        
        // Game state
        let gameState = {
            portfolio: 100000,
            accuracy: 0,
            streak: 0,
            bestStreak: 0,
            shots: 0,
            hits: 0,
            patience: 0,
            maxPatience: 100,
            isCharging: false,
            riskLevel: 'Conservative',
            gameRunning: false
        };
        
        // Trading opportunities and explosions pools
        const MAX_OPPORTUNITIES = 6;
        const MAX_EXPLOSIONS = 10;
        let opportunities = [];
        let explosions = [];
        
        // Object pools for better memory management
        const opportunityPool = [];
        const explosionPool = [];
        
        // Indian stock symbols
        const indianStocks = [
            'RELIANCE', 'TCS', 'INFY', 'HDFC', 'ICICI', 'SBIN', 'ITC', 'WIPRO',
            'ONGC', 'BHARTI', 'MARUTI', 'BAJFINANCE', 'HCLTECH', 'ASIANPAINT',
            'TITAN', 'NESTLEIND', 'KOTAKBANK', 'LTIM', 'TECHM', 'HINDUNILVR'
        ];
        
        // Lazy initialization to defer heavy setup
        function initializeGameResources() {
            gridCanvas = document.createElement('canvas');
            gridCtx = gridCanvas.getContext('2d');
            initPools();
            resizeCanvas();
        }
        
        // Responsive canvas sizing
        function resizeCanvas() {
            const container = canvas.parentElement;
            const maxWidth = Math.min(container.clientWidth - 40, 1000);
            const aspectRatio = 600 / 1000;
            
            canvas.width = maxWidth;
            canvas.height = maxWidth * aspectRatio;
            canvas.style.width = maxWidth + 'px';
            canvas.style.height = (maxWidth * aspectRatio) + 'px';
            
            // Resize grid canvas
            gridCanvas.width = canvas.width;
            gridCanvas.height = canvas.height;
            drawGrid();
        }
        
        // Draw grid once and cache it
        function drawGrid() {
            gridCtx.fillStyle = '#fafafa';
            gridCtx.fillRect(0, 0, gridCanvas.width, gridCanvas.height);
            
            gridCtx.strokeStyle = '#f0f0f0';
            gridCtx.lineWidth = 1;
            
            for (let x = 0; x <= gridCanvas.width; x += 50) {
                gridCtx.beginPath();
                gridCtx.moveTo(x, 0);
                gridCtx.lineTo(x, gridCanvas.height);
                gridCtx.stroke();
            }
            
            for (let y = 0; y <= gridCanvas.height; y += 50) {
                gridCtx.beginPath();
                gridCtx.moveTo(0, y);
                gridCtx.lineTo(gridCanvas.width, y);
                gridCtx.stroke();
            }
            
            gridDrawn = true;
        }
        
        // Initialize object pools
        function initPools() {
            for (let i = 0; i < MAX_OPPORTUNITIES; i++) {
                opportunityPool.push(new TradingOpportunity());
            }
            for (let i = 0; i < MAX_EXPLOSIONS; i++) {
                explosionPool.push(new Explosion(0, 0, 'profit', 0));
            }
        }
        
        class TradingOpportunity {
            constructor() {
                this.active = false;
                this.x = 0;
                this.y = 0;
                this.type = 'call';
                this.symbol = '';
                this.price = 0;
                this.profit = 0;
                this.risk = 0;
                this.size = 0;
                this.angle = 0;
                this.lifespan = 0;
                this.maxLifespan = 0;
                this.pulsing = 0;
                this.requiredPatience = 0;
            }
            
            init() {
                this.x = Math.random() * (canvas.width - 120) + 60;
                this.y = Math.random() * (canvas.height - 120) + 60;
                this.type = Math.random() < 0.3 ? 'call' : (Math.random() < 0.6 ? 'put' : 'trap');
                this.symbol = indianStocks[Math.floor(Math.random() * indianStocks.length)];
                this.price = Math.floor(Math.random() * 5000) + 100;
                this.profit = Math.floor(Math.random() * 50000) + 5000;
                this.risk = Math.floor(Math.random() * 30000) + 2000;
                this.size = 35 + Math.random() * 25;
                this.angle = 0;
                this.lifespan = 300 + Math.random() * 200;
                this.maxLifespan = this.lifespan;
                this.pulsing = 0;
                this.requiredPatience = this.type === 'trap' ? 20 : 60 + Math.random() * 30;
                this.active = true;
            }
            
            reset() {
                this.active = false;
            }
            
            update() {
                if (!this.active) return false;
                
                this.lifespan--;
                this.angle += 0.01;
                this.pulsing += 0.08;
                
                if (this.lifespan <= 0) {
                    this.reset();
                    return false;
                }
                return true;
            }
            
            draw() {
                if (!this.active) return;
                
                const alpha = Math.max(0.4, this.lifespan / this.maxLifespan);
                const pulse = 1 + Math.sin(this.pulsing) * 0.08;
                
                ctx.save();
                ctx.globalAlpha = alpha;
                ctx.translate(this.x, this.y);
                
                if (this.type === 'call') {
                    ctx.fillStyle = '#27ae60';
                    ctx.strokeStyle = '#219a52';
                } else if (this.type === 'put') {
                    ctx.fillStyle = '#3498db';
                    ctx.strokeStyle = '#2980b9';
                } else {
                    ctx.fillStyle = '#e74c3c';
                    ctx.strokeStyle = '#c0392b';
                }
                
                ctx.beginPath();
                ctx.arc(0, 0, this.size * pulse, 0, Math.PI * 2);
                ctx.fill();
                ctx.lineWidth = 3;
                ctx.stroke();
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath();
                ctx.arc(0, 0, (this.size - 8) * pulse, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = '#2c3e50';
                ctx.font = 'bold 11px Inter';
                ctx.textAlign = 'center';
                ctx.fillText(this.symbol, 0, -6);
                ctx.font = '9px Inter';
                ctx.fillText('‚Çπ' + this.price, 0, 4);
                ctx.font = 'bold 8px Inter';
                ctx.fillText(this.type.toUpperCase(), 0, 14);
                
                ctx.restore();
                
                if (gameState.patience < this.requiredPatience) {
                    ctx.fillStyle = '#e74c3c';
                    ctx.font = '12px Inter';
                    ctx.textAlign = 'center';
                    ctx.fillText('Need ' + Math.round(this.requiredPatience) + '%', this.x, this.y - this.size - 15);
                }
            }
            
            isClicked(mouseX, mouseY) {
                if (!this.active) return false;
                const dist = Math.sqrt((mouseX - this.x) ** 2 + (mouseY - this.y) ** 2);
                return dist < this.size;
            }
        }
        
        class Explosion {
            constructor(x, y, type, profit) {
                this.active = false;
                this.x = x;
                this.y = y;
                this.type = type;
                this.profit = profit;
                this.particles = [];
                this.lifespan = 0;
                this.maxLifespan = 60;
            }
            
            init(x, y, type, profit) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.profit = profit;
                this.lifespan = 60;
                this.maxLifespan = 60;
                this.particles = [];
                
                for (let i = 0; i < 12; i++) {
                    this.particles.push({
                        x: 0,
                        y: 0,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        size: Math.random() * 6 + 2,
                        alpha: 1
                    });
                }
                
                this.active = true;
            }
            
            reset() {
                this.active = false;
                this.particles = [];
            }
            
            update() {
                if (!this.active) return false;
                
                this.lifespan--;
                this.particles.forEach(p => {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vx *= 0.95;
                    p.vy *= 0.95;
                    p.alpha = this.lifespan / this.maxLifespan;
                });
                
                if (this.lifespan <= 0) {
                    this.reset();
                    return false;
                }
                return true;
            }
            
            draw() {
                if (!this.active) return;
                
                ctx.save();
                ctx.translate(this.x, this.y);
                
                this.particles.forEach(p => {
                    ctx.globalAlpha = p.alpha;
                    ctx.fillStyle = this.type === 'profit' ? '#27ae60' : '#e74c3c';
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                if (this.lifespan > 30) {
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = this.type === 'profit' ? '#27ae60' : '#e74c3c';
                    ctx.font = 'bold 14px Inter';
                    ctx.textAlign = 'center';
                    const sign = this.type === 'profit' ? '+' : '-';
                    ctx.fillText(sign + '‚Çπ' + Math.abs(this.profit), 0, -25);
                }
                
                ctx.restore();
            }
        }
        
        function spawnOpportunity() {
            if (opportunities.length >= MAX_OPPORTUNITIES) return;
            
            const opportunity = opportunityPool.find(opp => !opp.active);
            if (opportunity) {
                opportunity.init();
                opportunities.push(opportunity);
            }
        }
        
        function updatePatience() {
            if (gameState.isCharging && gameState.patience < gameState.maxPatience) {
                gameState.patience += 0.6;
            } else if (!gameState.isCharging && gameState.patience > 0) {
                gameState.patience -= 0.2;
            }
            
            gameState.patience = Math.max(0, Math.min(gameState.maxPatience, gameState.patience));
            
            const patienceFill = document.getElementById('patienceFill');
            const patiencePercent = document.getElementById('patiencePercent');
            patienceFill.style.width = gameState.patience + '%';
            patiencePercent.textContent = Math.round(gameState.patience) + '%';
            
            if (gameState.patience < 30) {
                gameState.riskLevel = 'Aggressive';
            } else if (gameState.patience < 70) {
                gameState.riskLevel = 'Moderate';
            } else {
                gameState.riskLevel = 'Conservative';
            }
        }
        
        function executeTrade(opportunity) {
            gameState.shots++;
            
            if (gameState.patience < opportunity.requiredPatience) {
                const loss = opportunity.risk;
                gameState.portfolio -= loss;
                gameState.streak = 0;
                createExplosion(opportunity.x, opportunity.y, 'loss', loss);
            } else if (opportunity.type === 'trap') {
                const loss = opportunity.risk;
                gameState.portfolio -= loss;
                gameState.streak = 0;
                createExplosion(opportunity.x, opportunity.y, 'loss', loss);
            } else {
                const profit = Math.round(opportunity.profit * (gameState.patience / 100));
                gameState.portfolio += profit;
                gameState.hits++;
                gameState.streak++;
                gameState.bestStreak = Math.max(gameState.bestStreak, gameState.streak);
                createExplosion(opportunity.x, opportunity.y, 'profit', profit);
            }
            
            gameState.accuracy = Math.round((gameState.hits / gameState.shots) * 100);
            
            opportunity.reset();
            opportunities = opportunities.filter(opp => opp !== opportunity);
            
            if (gameState.portfolio <= 0) {
                endGame();
            }
        }
        
        function createExplosion(x, y, type, profit) {
            if (explosions.length >= MAX_EXPLOSIONS) return;
            
            const explosion = explosionPool.find(exp => !exp.active);
            if (explosion) {
                explosion.init(x, y, type, profit);
                explosions.push(explosion);
            }
        }
        
        function updateHUD() {
            document.getElementById('portfolio').textContent = gameState.portfolio.toLocaleString();
            document.getElementById('accuracy').textContent = gameState.accuracy + '%';
            document.getElementById('streak').textContent = gameState.streak;
            document.getElementById('risk').textContent = gameState.riskLevel;
        }
        
        function gameLoop() {
            if (!gameState.gameRunning) return;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.drawImage(gridCanvas, 0, 0);
            
            opportunities = opportunities.filter(opp => {
                const alive = opp.update();
                if (alive) opp.draw();
                return alive;
            });
            
            explosions = explosions.filter(exp => {
                const alive = exp.update();
                if (alive) exp.draw();
                return alive;
            });
            
            if (Math.random() < 0.015 && opportunities.length < MAX_OPPORTUNITIES) {
                spawnOpportunity();
            }
            
            updatePatience();
            updateHUD();
            
            requestAnimationFrame(gameLoop);
        }
        
        function getEventPos(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            return {
                x: (e.clientX - rect.left) * scaleX,
                y: (e.clientY - rect.top) * scaleY
            };
        }
        
        function handleMouseDown(e) {
            if (!gameState.gameRunning) return;
            gameState.isCharging = true;
            e.preventDefault();
        }
        
        function handleMouseUp(e) {
            if (!gameState.gameRunning) return;
            gameState.isCharging = false;
            e.preventDefault();
        }
        
        function handleMouseMove(e) {
            if (!gameState.gameRunning) return;
            const rect = canvas.getBoundingClientRect();
            mouseX = e.clientX;
            mouseY = e.clientY;
            
            if (!crosshairUpdateRequested) {
                crosshairUpdateRequested = true;
                requestAnimationFrame(updateCrosshair);
            }
        }
        
        function updateCrosshair() {
            crosshair.style.transform = 'translate(' + mouseX + 'px, ' + mouseY + 'px)';
            crosshairUpdateRequested = false;
        }
        
        function handleClick(e) {
            if (!gameState.gameRunning) return;
            
            const pos = getEventPos(e);
            
            for (let i = opportunities.length - 1; i >= 0; i--) {
                if (opportunities[i].isClicked(pos.x, pos.y)) {
                    executeTrade(opportunities[i]);
                    break;
                }
            }
            e.preventDefault();
        }
        
        function handleTouchStart(e) {
            if (!gameState.gameRunning) return;
            
            gameState.isCharging = true;
            
            const pos = getEventPos(e.touches[0]);
            
            for (let i = opportunities.length - 1; i >= 0; i--) {
                if (opportunities[i].isClicked(pos.x, pos.y)) {
                    executeTrade(opportunities[i]);
                    break;
                }
            }
            e.preventDefault();
        }
        
        function handleTouchMove(e) {
            if (!gameState.gameRunning) return;
            if (e.touches.length > 0) {
                const rect = canvas.getBoundingClientRect();
                mouseX = e.touches[0].clientX;
                mouseY = e.touches[0].clientY;
                
                if (!crosshairUpdateRequested) {
                    crosshairUpdateRequested = true;
                    requestAnimationFrame(updateCrosshair);
                }
            }
            // Do not prevent default to allow scrolling
        }
        
        function startGame() {
            startScreen.classList.add('hidden');
            initializeGameResources();
            gameState.gameRunning = true;
            spawnOpportunity();
            spawnOpportunity();
            setupEventListeners();
            gameLoop();
        }
        
        function endGame() {
            gameState.gameRunning = false;
            document.getElementById('finalPortfolio').textContent = gameState.portfolio.toLocaleString();
            document.getElementById('finalAccuracy').textContent = gameState.accuracy;
            document.getElementById('finalStreak').textContent = gameState.bestStreak;
            document.getElementById('gameOver').style.display = 'block';
        }
        
        function restartGame() {
            gameState = {
                portfolio: 100000,
                accuracy: 0,
                streak: 0,
                bestStreak: 0,
                shots: 0,
                hits: 0,
                patience: 0,
                maxPatience: 100,
                isCharging: false,
                riskLevel: 'Conservative',
                gameRunning: true
            };
            
            opportunities.forEach(opp => opp.reset());
            explosions.forEach(exp => exp.reset());
            opportunities = [];
            explosions = [];
            
            document.getElementById('gameOver').style.display = 'none';
            startScreen.classList.add('hidden');
            gameLoop();
        }
        
        function setupEventListeners() {
            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('touchstart', handleTouchStart);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('touchend', handleMouseUp);
            canvas.addEventListener('click', handleClick);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('touchmove', handleTouchMove);
            window.addEventListener('resize', resizeCanvas);
        }
    </script>
</body>
</html>